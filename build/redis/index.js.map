{"version":3,"sources":["../../server/redis/index.js"],"names":["topStoryCache","req","res","next","checkForNewStories","client","lrange","err","data","status","send","sourceCache","get","stringifyAndAddToList","list","items","map","article","sadd","title","stringed","JSON","stringify","lpush","newStories","i","length","broken","sismember","reply","cacheAddition","splice"],"mappings":";;;;;;;;;AAAA;;AACA;;AAMO,eAAeA,aAAf,CAA6BC,GAA7B,EAAkCC,GAAlC,EAAuCC,IAAvC,EAA4C;AACjD,QAAMC,kBAAkB,EAAxB;;AACAC,iBAAOC,MAAP,CAAc,YAAd,EAA4B,CAA5B,EAA+B,EAA/B,EAAmC,CAACC,GAAD,EAAMC,IAAN,KAAe;AAChD,QAAGD,GAAH,EAAQ,MAAMA,GAAN;;AACR,QAAGC,IAAH,EAAQ;AACN;AACAN,MAAAA,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBF,IAArB;AACD,KAHD,MAGO;AACLL,MAAAA,IAAI;AACL;AACF,GARD;AASD;;AAEM,SAASQ,WAAT,CAAqBV,GAArB,EAA0BC,GAA1B,EAA+BC,IAA/B,EAAoC;AACzCE,iBAAOO,GAAP,CAAW,SAAX,EAAsB,CAACL,GAAD,EAAMC,IAAN,KAAe;AACnC,QAAGD,GAAG,IAAI,CAACC,IAAX,EAAgB;AACdL,MAAAA,IAAI;AACL,KAFD,MAEO,IAAGK,IAAH,EAAQ;AACbN,MAAAA,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqBF,IAArB;AACD;AACF,GAND;AAOD;;AAEM,SAASK,qBAAT,CAA+BC,IAA/B,EAAqCC,KAArC,EAA2C;AAC9CA,EAAAA,KAAK,CAACC,GAAN,CAAUC,OAAO,IAAI;AACnBZ,mBAAOa,IAAP,CAAY,YAAZ,EAA0BD,OAAO,CAACE,KAAlC;;AACA,QAAIC,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAeL,OAAf,CAAf;;AACAZ,mBAAOkB,KAAP,CAAaT,IAAb,EAAmBM,QAAnB;AACD,GAJD;AAKH,C,CAGD;;;AACA,eAAehB,kBAAf,GAAmC;AACjC;AACA,MAAIoB,UAAU,GAAG,MAAM,uCAAvB;;AAEA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,UAAU,CAACE,MAA9B,EAAsCD,CAAC,EAAvC,EAA0C;AACxC,QAAIE,MAAJ,CADwC,CAExC;AACA;;AACA,UAAMtB,eAAOuB,SAAP,CACJ,YADI,EACUJ,UAAU,CAACC,CAAD,CAAV,CAAcN,KADxB,EAEJ,OAAOZ,GAAP,EAAYsB,KAAZ,KAAsB;AACpB;AACA,UAAGA,KAAK,KAAK,CAAb,EAAe;AACb;AACA,YAAGJ,CAAC,KAAK,CAAT,EAAW;AACT;AACA,cAAIK,aAAa,GAAGN,UAAU,CAACO,MAAX,CAAkBN,CAAlB,CAApB;AACAZ,UAAAA,qBAAqB,CAAC,YAAD,EAAeiB,aAAf,CAArB;AACD,SANY,CAOb;;;AACAH,QAAAA,MAAM,GAAG,IAAT;AACD;AACF,KAdG,CAAN,CAJwC,CAoBxC;AACA;;AACA,QAAGA,MAAH,EAAU;AACR;AACD,KAFD,MAEQ,MAAM,sCAAN;AACT;AACF","sourcesContent":["import { client } from '../config/config'\nimport {\n  getMostRecent,\n  callArticles\n } from '../controller/articleController'\n\n\nexport async function topStoryCache(req, res, next){\n  await checkForNewStories()\n  client.lrange(\"topStories\", 0, 20, (err, data) => {\n    if(err) throw err;\n    if(data){\n      // let stringed = data.map(story => JSON.stringify(story))\n      res.status(200).send(data)\n    } else {\n      next()\n    }\n  })\n}\n\nexport function sourceCache(req, res, next){\n  client.get(\"sources\", (err, data) => {\n    if(err || !data){\n      next()\n    } else if(data){\n      res.status(200).send(data)\n    }\n  })\n}\n\nexport function stringifyAndAddToList(list, items){\n    items.map(article => {\n      client.sadd('mostRecent', article.title)\n      let stringed = JSON.stringify(article);\n      client.lpush(list, stringed)\n    })\n}\n\n\n// function to see if top story cache needs to be updated\nasync function checkForNewStories(){\n  // Calling the API for the 5 most recent stories\n  let newStories = await getMostRecent();\n\n  for(let i = 0; i < newStories.length; i++){\n    let broken\n    // checking to see if these 5 stories are in the redis list\n    // of the 5 most recent stories\n    await client.sismember(\n      'mostRecent', newStories[i].title,\n      async (err, reply) => {\n        // if yes, then we need to see if we need to update the list at all\n        if(reply === 1){\n          // if its the first iteration, then we don't have to do anything\n          if(i !== 0){\n            //if i > 0, then we need to update the top stories list with the stories we just pulled\n            let cacheAddition = newStories.splice(i);\n            stringifyAndAddToList('topStories', cacheAddition)\n          }\n          // in both cases we can break out of the loop\n          broken = true\n        }\n      }\n    )\n    // if the 5 most recent stories from the API call\n    // don't match at all, then we should refresh the whole cache\n    if(broken){\n      break\n    }  else await callArticles()\n  }\n}\n"],"file":"index.js"}